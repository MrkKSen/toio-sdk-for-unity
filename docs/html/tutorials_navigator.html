<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><style type="text/css">.markdown-body {padding: 20px 40px;}</style><style type="text/css">/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
/*# sourceURL=/Users/yaeda/.nodebrew/node/v14.3.0/lib/node_modules/md-to-pdf/node_modules/highlight.js/styles/github.css*/</style></head>
<body class="markdown-body">
<h1 id="チュートリアルcubenavigator">チュートリアル(CubeNavigator)</h1>
<h2 id="目次">目次</h2>
<ul>
<li><a href="tutorials_navigator.html#CubeNavigator">CubeNavigator</a><ul>
<li><a href="tutorials_navigator.html#CubeManager-%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6-CubeNavigator-%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B">CubeManager を使って CubeNavigator を利用する</a><ul>
<li><a href="tutorials_navigator.html#%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%A7%E3%82%AD%E3%83%A5%E3%83%BC%E3%83%96%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88">非同期でキューブを制御する場合</a></li>
<li><a href="tutorials_navigator.html#%E5%90%8C%E6%9C%9F%E3%81%A7%E3%82%AD%E3%83%A5%E3%83%BC%E3%83%96%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B%E5%A0%B4%E5%90%88">同期でキューブを制御する場合</a></li>
<li><a href="tutorials_navigator.html#CubeManager-%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84%E3%81%A7-CubeNavigator-%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B">CubeManager を使わないで CubeNavigator を利用する</a></li>
</ul>
</li>
<li><a href="tutorials_navigator.html#CubeNavigator-%E3%81%AB%E3%82%88%E3%82%8B%E8%A1%9D%E7%AA%81%E5%9B%9E%E9%81%BF">CubeNavigator による衝突回避</a><ul>
<li><a href="tutorials_navigator.html#%E8%A1%9D%E7%AA%81%E3%82%92%E5%9B%9E%E9%81%BF%E3%81%97%E3%81%A4%E3%81%A4%E7%9B%AE%E6%A8%99%E3%81%AB%E7%A7%BB%E5%8B%95%E3%81%99%E3%82%8B-Navi2Target-%E9%96%A2%E6%95%B0">衝突を回避しつつ目標に移動する Navi2Target 関数</a></li>
<li><a href="tutorials_navigator.html#%E7%9B%AE%E6%A8%99%E3%81%8B%E3%82%89%E9%9B%A2%E3%82%8C%E3%82%8B-NaviAwayTarget-%E9%96%A2%E6%95%B0">目標から離れる NaviAwayTarget 関数</a></li>
</ul>
</li>
<li><a href="tutorials_navigator.html#%E3%83%9C%E3%82%A4%E3%83%89%E3%81%AB%E3%82%88%E3%82%8B%E9%9B%86%E5%9B%A3%E5%88%B6%E5%BE%A1">ボイドによる集団制御</a></li>
<li><a href="tutorials_navigator.html#%E3%83%9C%E3%82%A4%E3%83%89--%E8%A1%9D%E7%AA%81%E5%9B%9E%E9%81%BF">ボイド + 衝突回避</a></li>
</ul>
</li>
</ul>
<h1 id="cubenavigator">CubeNavigator</h1>
<p>CubeNavigator を使うことで、複数のキューブがお互いの動きを考慮しながら一斉にうまく移動することが出来ます。</p>
<p>CubeNavigator の詳細については<a href="usage_navigator.html">こちら</a>を参照してください。</p>
<h2 id="cubemanager-を使って-cubenavigator-を利用する">CubeManager を使って CubeNavigator を利用する</h2>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-Navigator/0.BasicScene/」 にあります。</p>
</blockquote>
<p>CubeNavigator は CubeManager がキューブ接続時に自動的に作成してメンバ変数のリストに入れています。</p>
<h3 id="非同期でキューブを制御する場合">非同期でキューブを制御する場合</h3>
<p>下記のサンプルコードでは、 Update の中で、CubeNavigator の制御可能状態を確認してから、制御を行っています。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavigatorBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators)
        {
            <span class="hljs-comment">// Controllable になるタイミング（フレーム）はキューブそれぞれ、つまり非同期</span>
            <span class="hljs-keyword">if</span> (cubeManager.IsControllable(navigator))
            {
                navigator.Update(); <span class="hljs-comment">// 非同期版の場合、必ずこのメソッドを呼んでください。</span>
                navigator.handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
            }
        }
    }
}</code></pre><p>制御可能状態は皆それぞれなので、「非同期」になります。</p>
<h3 id="同期でキューブを制御する場合">同期でキューブを制御する場合</h3>
<p>以下のようにすると、すべての navigator が、50ms ごとの同じフレームで制御されます。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavigatorBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// 同期</span>
        <span class="hljs-keyword">if</span> (cubeManager.synced)
        {
            <span class="hljs-comment">// navigator の Update も synced の呼び出し際に内部でやってくれる。</span>
            <span class="hljs-comment">// 個別の navigator を操作できる。</span>
            cubeManager.navigators[<span class="hljs-number">0</span>].handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
        }
    }
}</code></pre><p>上記は、単純に同期して各 navigator を個別に操作しています。</p>
<p>すべての navigator を一斉に動かす場合は、syncNavigators を使うと便利です。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavigatorBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// すべてのキューブが controllable になったら、syncNavigators が navigators を提供</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.syncNavigators)
        {
            <span class="hljs-comment">// navigator の Update も syncNavigators の呼び出し際に内部でやってくれる。</span>
            navigator.handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
        }
    }
}</code></pre><h3 id="cubemanager-を使わないで-cubenavigator-を利用する">CubeManager を使わないで CubeNavigator を利用する</h3>
<p>CubeManager を使わない場合には、以下のように Cube クラスを使って CubeNavigator インスタンスを作成してください。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavigatorBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    <span class="hljs-keyword">float</span> intervalTime = <span class="hljs-number">0.05f</span>;
    <span class="hljs-keyword">float</span> elapsedTime = <span class="hljs-number">0</span>;
    List&lt;CubeNavigator&gt; navigators;
    <span class="hljs-keyword">bool</span> started = <span class="hljs-literal">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> peripheral = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> NearScanner(<span class="hljs-number">2</span>).Scan();
        <span class="hljs-keyword">var</span> cubes = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> CubeConnecter().Connect(peripheral);

        <span class="hljs-comment">// create navigators</span>
        <span class="hljs-keyword">this</span>.navigators = <span class="hljs-keyword">new</span> List&lt;CubeNavigator&gt;();
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> cube <span class="hljs-keyword">in</span> cubes)
            <span class="hljs-comment">// create navigator and add to navigators</span>
            <span class="hljs-keyword">this</span>.navigators.Add(<span class="hljs-keyword">new</span> CubeNavigator(cube));

        <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!started) <span class="hljs-keyword">return</span>;

        elapsedTime += Time.deltaTime;

        <span class="hljs-keyword">if</span> (intervalTime &lt; elapsedTime)
        {
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.navigators)
                <span class="hljs-comment">// update state of navigator (including internal handle)</span>
                navigator.Update();

            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.navigators)
                <span class="hljs-comment">// use internal handle to rotate cube</span>
                navigator.handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);

            elapsedTime = <span class="hljs-number">0.0f</span>;
        }
    }
}</code></pre><h2 id="cubenavigator-による衝突回避">CubeNavigator による衝突回避</h2>
<h3 id="衝突を回避しつつ目標に移動する-navi2target-関数">衝突を回避しつつ目標に移動する Navi2Target 関数</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-Navigator/1.Navi2TargetScene/」 にあります。</p>
</blockquote>
<p>衝突を回避しつつキューブを目標に移動させるには Navi2Target 関数を利用します。<br>
この関数は CubeHandle クラスの Move2Target 関数に相当します。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// x,ｙ 目標座標、maxSpd 最大速度、rotateTime 希望回転時間（CubeHandle使い方に参考）、tolerance 到達判定閾値（目標との距離）</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Movement <span class="hljs-title">Navi2Target</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">int</span> maxSpd=<span class="hljs-number">70</span>, <span class="hljs-keyword">int</span> rotateTime=<span class="hljs-number">250</span>, <span class="hljs-keyword">double</span> tolerance=<span class="hljs-number">20</span></span>)</span>;</code></pre><h4 id="例-1-目標座標の設定で、2-つのキューブを交差する方向で往復運動させる">例 1:　目標座標の設定で、2 つのキューブを交差する方向で往復運動させる</h4>
<p>以下の例では、2 つのキューブに互いに回避しあって往復運動をさせています。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/avoid_basic.gif"></div>

<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavigatorHLAvoid</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-keyword">int</span> navigator0_phase = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> navigator1_phase = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">if</span> (cubeManager.synced)
        {
            <span class="hljs-comment">// navigator 0</span>
            {
                <span class="hljs-keyword">if</span> (navigator0_phase == <span class="hljs-number">0</span>){
                    <span class="hljs-keyword">var</span> mv = cubeManager.navigators[<span class="hljs-number">0</span>].Navi2Target(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, maxSpd:<span class="hljs-number">50</span>).Exec();
                    <span class="hljs-keyword">if</span> (mv.reached) navigator0_phase = <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator0_phase == <span class="hljs-number">1</span>){
                    <span class="hljs-keyword">var</span> mv = cubeManager.navigators[<span class="hljs-number">0</span>].Navi2Target(<span class="hljs-number">350</span>, <span class="hljs-number">350</span>, maxSpd:<span class="hljs-number">50</span>).Exec();
                    <span class="hljs-keyword">if</span> (mv.reached) navigator0_phase = <span class="hljs-number">0</span>;
                }
            }

            <span class="hljs-comment">// navigator 1</span>
            {
                <span class="hljs-keyword">if</span> (navigator1_phase == <span class="hljs-number">0</span>){
                    <span class="hljs-keyword">var</span> mv = cubeManager.navigators[<span class="hljs-number">1</span>].Navi2Target(<span class="hljs-number">180</span>, <span class="hljs-number">350</span>).Exec();
                    <span class="hljs-keyword">if</span> (mv.reached) navigator1_phase = <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator1_phase == <span class="hljs-number">1</span>){
                    <span class="hljs-keyword">var</span> mv = cubeManager.navigators[<span class="hljs-number">1</span>].Navi2Target(<span class="hljs-number">330</span>, <span class="hljs-number">180</span>).Exec();
                    <span class="hljs-keyword">if</span> (mv.reached) navigator1_phase = <span class="hljs-number">0</span>;
                }
            }
        }
    }
}</code></pre><h4 id="例-2-一つのキューブがもう一つを無視するようにする">例 2:　一つのキューブがもう一つを無視するようにする</h4>
<p>初期化設定を変更することで、特定のキューブは衝突回避をしないようにすることも可能です。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// CubeNavigator のメソッド</span>
<span class="hljs-comment">// すべての認識できる対象を削除する</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearOther</span>(<span class="hljs-params"></span>)</span>;</code></pre><p>以下の例では、例 1 の初期化設定を変更することで、一つのキューブがもう一つを無視するようにしています。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/avoid_priority.gif"></div>

<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
{
    cubeManager = <span class="hljs-keyword">new</span> CubeManager();
    <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);

    <span class="hljs-comment">// By default, each navigator is able to see all others</span>
    <span class="hljs-comment">// But you can also manually make a navigator "blind"</span>
    cubeManager.navigators[<span class="hljs-number">0</span>].ClearOther();
}</code></pre><blockquote>
<p>この例では、ラグによって回避がちょっと不自然です。</p>
</blockquote>
<h4 id="例-3-例-2-の初期化設定を変更することで、予測を起用して、ラグの影響を軽減させる">例 3:　例 2 の初期化設定を変更することで、予測を起用して、ラグの影響を軽減させる</h4>
<p>さらに、初期化設定を変更することで、キューブの移動を予測してラグの影響を軽減させ より自然に衝突回避を行うことが出来ます。<br></p>
<pre><code class="hljs c#"><span class="hljs-comment">// CubeNavigator のメンバー変数</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> usePred = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// CubeHandle の予測値を使うか</span></code></pre><p>以下の例では、例 2 の初期化設定を変更することで、予測を起用して、ラグの影響を軽減しています。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/avoid_pred.gif"></div>

<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
{
    cubeManager = <span class="hljs-keyword">new</span> CubeManager();
    <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);

    cubeManager.navigators[<span class="hljs-number">0</span>].ClearOther();

    <span class="hljs-comment">// use prediction</span>
    cubeManager.navigators[<span class="hljs-number">1</span>].usePred = <span class="hljs-literal">true</span>;
}</code></pre><h3 id="目標から離れる-naviawaytarget-関数">目標から離れる NaviAwayTarget 関数</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-Navigator/2.NaviAwayTargetScene/」 にあります。</p>
</blockquote>
<p>NaviAwayTarget 関数を使うと、 Navi2Target 関数とは逆にキューブが目標から離れます。<br>
(キューブの視野内に一番離れるところに移動します。)</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Movement <span class="hljs-title">NaviAwayTarget</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">int</span> maxSpd=<span class="hljs-number">70</span>, <span class="hljs-keyword">int</span> rotateTime=<span class="hljs-number">250</span></span>)</span>;</code></pre><h4 id="例-鬼ごっこ">例:　鬼ごっこ</h4>
<p>以下の例では 2 台のキューブが 「鬼ごっこ」 をするサンプルです。<br>
キューブ 0 はキューブ 1 を追いかけ、反対にキューブ 1 はキューブ 0 から逃げるように動きます。</p>
<p>衝突回避をしてしまうと鬼ごっこにならない（捕まえられない）ので、この例では 互いに回避しないようにするために ClearOther 関数を呼ぶようにしています。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/avoid_oni.gif"></div>

<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NaviAwayTargetTutorial</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;

    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);

        <span class="hljs-comment">// By default, each navigator is able to see all others</span>
        <span class="hljs-comment">// But you can also manually make a navigator "blind"</span>
        cubeManager.navigators[<span class="hljs-number">0</span>].ClearOther();
        cubeManager.navigators[<span class="hljs-number">1</span>].ClearOther();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">if</span> (cubeManager.synced)
        {
            <span class="hljs-keyword">var</span> navi0 = cubeManager.navigators[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">var</span> navi1 = cubeManager.navigators[<span class="hljs-number">1</span>];

            <span class="hljs-comment">// navigator 0</span>
            navi0.Navi2Target(navi1.handle.pos, maxSpd:<span class="hljs-number">50</span>).Exec();

            <span class="hljs-comment">// navigator 1</span>
            navi1.NaviAwayTarget(navi0.handle.pos, maxSpd:<span class="hljs-number">80</span>).Exec();
        }
    }
}</code></pre><h3 id="ボイドによる集団制御">ボイドによる集団制御</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-Navigator/3.BoidsScene/」 にあります。</p>
</blockquote>
<p>「ボイド」とは、鳥の集団行動を擬似し、キューブ達を互いに一定距離を保ちながら群れとして移動させるアルゴリズムです。</p>
<h4 id="例-1-複数のキューブをボイドとして一緒に移動させる">例 1:　複数のキューブをボイドとして一緒に移動させる</h4>
<p>CubeNavigator クラスはデフォルトで衝突回避のみを行う設定になっています。<br>
ボイドによる制御を行うには、まずこの設定を変更する必要があります。</p>
<p>CubeNavigator クラスの mode メンバ変数を規定値 (AVOID： 衝突回避のみ) から BOIDS に変更してください。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// Navigator のモード</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Mode : <span class="hljs-keyword">byte</span>
{
    AVOID = <span class="hljs-number">0</span>,
    BOIDS = <span class="hljs-number">1</span>,
    BOIDS_AVOID = <span class="hljs-number">2</span>,
}
<span class="hljs-comment">// Navigator のメンバー変数</span>
<span class="hljs-keyword">public</span> Mode mode = Mode.AVOID;</code></pre><p>以下の例では、複数のキューブがボイドとして一緒に移動します。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/boids.gif"></div>

<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BoidsTutorial</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">5</span>);

        <span class="hljs-comment">// set to BOIDS only mode</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navi <span class="hljs-keyword">in</span> cubeManager.navigators)
            navi.mode = CubeNavigator.Mode.BOIDS;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// ------ Sync ------</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.syncNavigators)
        {
            <span class="hljs-keyword">var</span> mv = navigator.Navi2Target(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>, maxSpd:<span class="hljs-number">50</span>).Exec();
        }
    }
}</code></pre><blockquote>
<p>散らがっていたキューブ達は群がって一緒に目標に向かう事ができましたが、うまく停止できていません。</p>
</blockquote>
<h4 id="例-2-ボイドでないキューブを追加して、より群れらしく行動させる">例 2:　ボイドでないキューブを追加して、より群れらしく行動させる</h4>
<p>比較対象 (この例では 群れの先頭役) としてボイドでないキューブを追加することで、複数の個体が群がって行動する効果を表現することが出来ます。</p>
<p>既定設定では全てのキューブが互いに同じボイドの同士 (一つの群れ) と認識していますので、
CubeNavigator クラスの SetRelation 関数を使って特定の個体をボイドから排除する必要があります。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// CubeNavigator のメソッド</span>
<span class="hljs-comment">// 他者（達）への認識を設定する</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetRelation</span>(<span class="hljs-params">List&lt;CubeNavigator&gt; others, Relation relation</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetRelation</span>(<span class="hljs-params">List&lt;Navigator&gt; others, Relation relation</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetRelation</span>(<span class="hljs-params">Navigator other, Relation relation</span>)</span>;</code></pre><p>ボイドでないキューブを追加して、より群れらしく行動させたのが以下の例です。<br>
説明の便利さのため、ボイドでないキューブとボイドの中の一台の LED を点灯させています。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/boids_relation.gif"></div>

<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
{
    cubeManager = <span class="hljs-keyword">new</span> CubeManager();
    cubeManager.MultiConnect(<span class="hljs-number">6</span>);

    <span class="hljs-comment">// get Cube (3) and Cube (5)</span>
    CubeNavigator navigatorNotBoids = <span class="hljs-literal">null</span>;
    CubeNavigator navigatorBoids = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators){
        <span class="hljs-keyword">if</span> (navigator.cube.id == <span class="hljs-string">"Cube (5)"</span>)
            navigatorNotBoids = navigator;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator.cube.id == <span class="hljs-string">"Cube (3)"</span>)
            navigatorBoids = navigator;
    }

    navigatorBoids.cube.TurnLedOn(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    <span class="hljs-comment">// Green</span>
    navigatorNotBoids.cube.TurnLedOn(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// Red</span>

    <span class="hljs-comment">// set to BOIDS only mode, except Cube (5) (Red)</span>
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators)
        <span class="hljs-keyword">if</span> (navigator != navigatorNotBoids)
            navigator.mode = CubeNavigator.Mode.BOIDS;

    <span class="hljs-comment">// By default, all navigators are in one group of boids</span>
    <span class="hljs-comment">// here, separate Red cube from the group</span>
    navigatorNotBoids.SetRelation(cubeManager.navigators, CubeNavigator.Relation.NONE);
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators)
        navigator.SetRelation(navigatorNotBoids, CubeNavigator.Relation.NONE);
}</code></pre><p>ボイドでない赤いキューブがまっすぐに目標に前進し、隣の緑のキューブが後ろの仲間達を少し待ってから目標に向かうようになりました。<br>
より自然な群れの動きになったかと思います。</p>
<blockquote>
<p>BOIDS モードのキューブは ボイドでないキューブを回避することが出来ません。<br>
そのため、複雑の構成で BOIDS モードを使うことはおすすめしません。 後述する BOIDS_AVOID モードの仕様を検討してください。</p>
</blockquote>
<h3 id="ボイド--衝突回避">ボイド + 衝突回避</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-Navigator/4.BoidsAvoidScene/」 にあります。</p>
</blockquote>
<p>ボイドと衝突回避の組み合わせを使うことで、ボイドの群がる特性と安定的で自然な回避能力を同時に発揮します。</p>
<p>ボイドのサンプルと同じく、CubeNavigator クラスの mode メンバ変数を BOIDS_AVOID にすることで、 ボイド+衝突回避 のモードにすることが出来ます。</p>
<h4 id="例-キューブの群れが、群れではないキューブを避けて目標に向かう">例: キューブの群れが、群れではないキューブを避けて目標に向かう</h4>
<p>以下の例では、5 個のキューブの群れが 1 個の群れではないキューブを避けて目標に向かいます。</p>
<div align="center"><img width="256" src="../res/tutorial_navigator/boids_avoid.gif"></div>

<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BoidsAvoidTutorial</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;

    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">6</span>);

        <span class="hljs-comment">// get Cube (5)</span>
        CubeNavigator navigatorNotBoids = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators){
            <span class="hljs-keyword">if</span> (navigator.cube.id == <span class="hljs-string">"Cube (5)"</span>)
                navigatorNotBoids = navigator;
        }
        <span class="hljs-comment">//navigatorNotBoids.cube.TurnLedOn(255,0,0,0); // Red</span>

        <span class="hljs-comment">// set to BOIDS_AVOID mode, except Cube (5) (Red)</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators){
            navigator.mode = CubeNavigator.Mode.BOIDS_AVOID;
            navigator.usePred = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-comment">// By default, all navigators are in one group of boids</span>
        <span class="hljs-comment">// here, separate Red cube from the group</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.navigators)
            navigator.SetRelation(navigatorNotBoids, CubeNavigator.Relation.NONE);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// ------ Sync ------</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> navigator <span class="hljs-keyword">in</span> cubeManager.syncNavigators)
        {
            <span class="hljs-comment">// Cube (5) stay still</span>
            <span class="hljs-keyword">if</span> (navigator.cube.id != <span class="hljs-string">"Cube (5)"</span>)
                navigator.Navi2Target(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>, maxSpd:<span class="hljs-number">50</span>).Exec();
        }
    }
}</code></pre><p>盤面のスペースが足りなくてボイドの効果があまり見えないですが、衝突を回避しつつ きちんと停止するようになりました。</p>



</body></html>
