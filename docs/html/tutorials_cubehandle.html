<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><style type="text/css">.markdown-body {padding: 20px 40px;}</style><style type="text/css">/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
/*# sourceURL=/Users/yaeda/.nodebrew/node/v14.3.0/lib/node_modules/md-to-pdf/node_modules/highlight.js/styles/github.css*/</style></head>
<body class="markdown-body">
<h1 id="チュートリアルcubehandle">チュートリアル(CubeHandle)</h1>
<h2 id="目次">目次</h2>
<ul>
<li><a href="tutorials_cubehandle.html#CubeManager-%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E3%82%AD%E3%83%A5%E3%83%BC%E3%83%96%E3%81%AE%E5%90%8C%E6%9C%9F%E5%88%B6%E5%BE%A1">CubeManager を使ったキューブの同期制御</a></li>
<li><a href="tutorials_cubehandle.html#CubeHandle">CubeHandle</a><ul>
<li><a href="tutorials_cubehandle.html#CubeHandle%E3%81%AEMove%E9%96%A2%E6%95%B0%E3%81%A8MoveRaw%E9%96%A2%E6%95%B0">CubeHandle の Move 関数と MoveRaw 関数</a></li>
<li><a href="tutorials_cubehandle.html#%E3%82%AD%E3%83%A5%E3%83%BC%E3%83%96%E3%81%A8%E3%81%AE%E9%80%9A%E4%BF%A1%E9%87%8F%E3%82%92%E6%8A%91%E3%81%88%E3%82%8B-One-shot-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89">キューブとの通信量を抑える One-shot メソッド</a></li>
<li><a href="tutorials_cubehandle.html#%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%9F%E5%BA%A7%E6%A8%99%E6%96%B9%E5%90%91%E3%81%AB%E5%88%B0%E9%81%94%E3%81%99%E3%82%8B-Closed-Loop-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89">指定した座標/方向に到達する Closed-Loop メソッド</a></li>
</ul>
</li>
<li><a href="tutorials_cubehandle.html#Follow-TargetPole-%E3%83%87%E3%83%A2">Follow TargetPole デモ</a></li>
</ul>
<h2 id="cubemanager-を使ったキューブの同期制御">CubeManager を使ったキューブの同期制御</h2>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-CubeHandle/0.BasicScene/」 にあります。</p>
</blockquote>
<p>チュートリアル基本編で説明した CubeManager は複数のキューブをそれぞれ任意のタイミング(非同期)で制御するものです。<br>
このような非同期の通信はキューブの移動制御を行う上で問題になる時があり、キューブを指定した一定のタイミング(同期)で制御したい場合があります。</p>
<p>そのような同期制御を行うための仕組みが CubeManager には用意されています。</p>
<h3 id="非同期でキューブを制御する場合">非同期でキューブを制御する場合</h3>
<p>CubeManager は自動的に、接続した Cube から CubeHandle を作成して、メンバー変数のリストに入れています。<br>
下記のサンプルコードでは、 Update の中で CubeManager が保持している CubeHandle の制御可能状態を確認してから、制御を行っています。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandleBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handle <span class="hljs-keyword">in</span> cubeManager.handles)
        {
            <span class="hljs-comment">// Controllable になるタイミング（フレーム）はキューブそれぞれ、つまり非同期</span>
            <span class="hljs-keyword">if</span> (cubeManager.IsControllable(handle))
            {
                handle.Update(); <span class="hljs-comment">// 非同期版の場合、必ずこのメソッドを呼んでください。</span>
                handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
            }
        }
    }
}</code></pre><p>このサンプルでは制御可能状態は皆それぞれなので、「非同期」になります。</p>
<h3 id="同期でキューブを制御する場合">同期でキューブを制御する場合</h3>
<p>以下のようにすると、すべての handle が、50ms ごとの同じフレームで制御されます。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandleBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// 同期</span>
        <span class="hljs-keyword">if</span> (cubeManager.synced)
        {
            <span class="hljs-comment">// handle の Update も synced の呼び出し際に内部でやってくれる。</span>
            <span class="hljs-comment">// 個別の handle を操作できる。</span>
            cubeManager.handles[<span class="hljs-number">0</span>].MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
        }
    }
}</code></pre><p>上記は、単に同期して各 handle を個別に操作しています。</p>
<p>すべての handle を一斉に動かす場合は、syncHandles を使うと便利です。</p>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandleBasic</span> : <span class="hljs-title">MonoBehaviour</span>
{
    CubeManager cubeManager;
    <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        cubeManager = <span class="hljs-keyword">new</span> CubeManager();
        <span class="hljs-keyword">await</span> cubeManager.MultiConnect(<span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// すべてのキューブが controllable になったら、syncHandles が handles を提供</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handle <span class="hljs-keyword">in</span> cubeManager.syncHandles)
        {
            <span class="hljs-comment">// handle の Update も syncHandles の呼び出し際に内部でやってくれる。</span>
            handle.MoveRaw(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1000</span>);
        }
    }
}</code></pre><h2 id="cubehandle">CubeHandle</h2>
<p>チュートリアル基本編でキューブの移動制御を行っていた Cube クラスは <a href="https://toio.github.io/toio-spec/">toio™ コアキューブ技術仕様</a> に従った基礎機能を提供するクラスで、キューブの移動は左右のモーター制御となっています。
このようなモーターの制御だけで複雑な移動を行うのは大変なので ToioSDK ではキューブの移動制御をより扱いやすくした CubeHandle クラスを用意しています。</p>
<p>CubeHandle クラスは、以下のような移動制御を提供します。</p>
<ul>
<li>前進量、回転量の指定で移動を制御</li>
<li>一回の命令で指定した距離を移動、指定した角度回転</li>
<li>指定した座標に到達するように移動、指定した方向に到達するように回転</li>
</ul>
<p>CubeHandle の詳細については<a href="cubehandle.html">こちら</a>を参照してください。</p>
<h3 id="cubehandle-の-move-関数と-moveraw-関数">CubeHandle の Move 関数と MoveRaw 関数</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-CubeHandle/1.MoveScene/」 にあります。</p>
</blockquote>
<p>Cube クラスの Move 関数では左右のモーターの出力を指定することでキューブの移動を制御しています。
それに対して、CubeHandle クラスの Move 関数では、 より直感的に扱えるように 直進+回転の量を指定する方式にしています。<br>
そのほか、</p>
<ul>
<li>キューブのモーターが回転しないほど移動量が小さかった (この範囲をデッドゾーンと呼びます) 場合、デッドゾーンにある入力を一番近い有効な入力に置き換える</li>
<li>未来の軌跡を予測し、継続時間を制限することで、指定した範囲(ボーダー)外へキューブが出ていかないようにする</li>
</ul>
<p>といった機能もあります。</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move</span>(<span class="hljs-params">
    <span class="hljs-keyword">double</span> translate,           // 前進指示値
    <span class="hljs-keyword">double</span> rotate,              // 回転指示値
    <span class="hljs-keyword">int</span> durationMs = <span class="hljs-number">1000</span>,      // 継続時間（ms）
    <span class="hljs-keyword">bool</span> deadzoneBias = <span class="hljs-literal">false</span>,  // デッドゾーン処理の方法
    <span class="hljs-keyword">bool</span> border = <span class="hljs-literal">true</span>,         // ボーダー制限のありなし
    Cube.ORDER_TYPE order = Cube.ORDER_TYPE.Weak    // 指示の優先度
    </span>)</span>;
<span class="hljs-comment">// Movement を実行</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move</span>(<span class="hljs-params">Movement mv, <span class="hljs-keyword">bool</span> border = <span class="hljs-literal">true</span></span>)</span>;
<span class="hljs-comment">// Movement の継続時間を書き換えて実行</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move</span>(<span class="hljs-params">Movement mv, <span class="hljs-keyword">int</span> durationMs, <span class="hljs-keyword">bool</span> border = <span class="hljs-literal">true</span></span>)</span>;
<span class="hljs-comment">// Movement の優先度を書き換えて実行</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move</span>(<span class="hljs-params">Movement mv, Cube.ORDER_TYPE order, <span class="hljs-keyword">bool</span> border = <span class="hljs-literal">true</span></span>)</span>;
<span class="hljs-comment">// Movement の継続時間と優先度を書き換えて実行</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move</span>(<span class="hljs-params">Movement mv, <span class="hljs-keyword">int</span> durationMs, Cube.ORDER_TYPE order, <span class="hljs-keyword">bool</span> border = <span class="hljs-literal">true</span></span>)</span>;</code></pre><p>また、Cube クラスの Move 関数に相当する関数として MoveRaw も用意しています。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// uL 左モーターの指示値、uR 右モーターの指示値、durationMs 継続時間（ms）、order 指示の優先度</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MoveRaw</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> uL, <span class="hljs-keyword">double</span> uR, <span class="hljs-keyword">int</span> durationMs = <span class="hljs-number">1000</span>, Cube.ORDER_TYPE order = Cube.ORDER_TYPE.Weak</span>)</span>;</code></pre><p>以下は Move 関数と MoveRaw 関数を使ったサンプルコードです。</p>
<div align="center"><img width="256" src="../res/tutorial_cubehandle/move.gif"></div>

<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
{
    elapsedTime += Time.deltaTime;
    <span class="hljs-keyword">if</span> (<span class="hljs-number">1.7f</span> &lt; elapsedTime)
    {
        cubeManager.handles[<span class="hljs-number">0</span>].Update();
        cubeManager.handles[<span class="hljs-number">1</span>].Update();

        <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">0</span>)
        {
            Debug.Log(<span class="hljs-string">"---------- Phase 0 - 右回転 ----------"</span>);

            <span class="hljs-comment">// MoveRawで右回転：　左モーター指令 50、右モーター指令 -50、継続時間 560</span>
            cubeManager.handles[<span class="hljs-number">0</span>].MoveRaw(<span class="hljs-number">50</span>, <span class="hljs-number">-50</span>, <span class="hljs-number">560</span>);
            <span class="hljs-comment">// moveで右回転：　前進指令 0、回転指令 50、(希望)継続時間 560</span>
            cubeManager.handles[<span class="hljs-number">1</span>].Move(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">560</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">1</span>)
        {
            Debug.Log(<span class="hljs-string">"---------- Phase 1 - 前進 ----------"</span>);

            cubeManager.handles[<span class="hljs-number">0</span>].MoveRaw(<span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">600</span>);
            cubeManager.handles[<span class="hljs-number">1</span>].Move(<span class="hljs-number">80</span>, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">2</span>)
        {
            Debug.Log(<span class="hljs-string">"---------- Phase 2 - デッドゾーン対処 ----------"</span>);
            <span class="hljs-comment">// MoveRaw と move は入力表現が違う。move の方がもっと直感的になっている。</span>
            <span class="hljs-comment">// MoveRaw はほぼそのままの入力を Cube.move に渡すが、</span>
            <span class="hljs-comment">// move は【デッドゾーン対処】と【ボーダー制限】を行っている。</span>

            cubeManager.handles[<span class="hljs-number">0</span>].MoveRaw(<span class="hljs-number">-9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>);
            cubeManager.handles[<span class="hljs-number">1</span>].Move(<span class="hljs-number">-4</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">100</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">3</span>)
        {
            Debug.Log(<span class="hljs-string">"---------- Phase 3 - ボーダー ----------"</span>);
            <span class="hljs-comment">// 緑キューブはボーダー前に止まった。</span>

            cubeManager.handles[<span class="hljs-number">0</span>].MoveRaw(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>);
            cubeManager.handles[<span class="hljs-number">1</span>].Move(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">4</span>)
        {
            Debug.Log(<span class="hljs-string">"---------- Phase 4 - ボーダー ----------"</span>);
            <span class="hljs-comment">// ボーダー制限は、予測モデルによって継続時間を制限することで、後退や回転の場合でも効く。</span>

            cubeManager.handles[<span class="hljs-number">1</span>].Move(<span class="hljs-number">-80</span>, <span class="hljs-number">30</span>, <span class="hljs-number">2000</span>);
        }

        elapsedTime = <span class="hljs-number">0.0f</span>; phase += <span class="hljs-number">1</span>;
    }
}</code></pre><p>CubeHandle クラスの Move 関数および MoveRaw 関数が呼び出される度に、キューブに通信で移動するよう指令を送り、受信したキューブが指令に沿って移動します。<br>
CubeHandle では、そのほかに 移動の指令を扱う Movement クラスを一回出力し、それに対して Exec 関数を実行することでも同様の処理が行われます。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// Movement を使った移動</span>
Movement mv = handle.HogeMethod(...);
mv.Exec();

<span class="hljs-comment">// CubeHandle.Move を使った移動</span>
handle.Move(mv);</code></pre><h3 id="キューブとの通信量を抑える-one-shot-メソッド">キューブとの通信量を抑える One-shot メソッド</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-CubeHandle/2.OneShotScene/」 にあります。</p>
</blockquote>
<p>CubeHandle クラスの Closed-loop メソッド（下で説明）は目的に到達するために何度も繰り返し実行する想定です。
処理を実行するたびにキューブと Bluetooth 通信をすることなるため、 移動しながら LED を点滅したり、音を鳴らしたりすると通信量が多くなりすぎてしまいます。</p>
<p>One-shot メソッドは、この問題を解決するための機能で、 目標に達するために一回だけ呼び出せば良いので移動をするのに必要な通信量を抑えることが出来ます。<br>
（Open-Loop なので、結果の保証はありません）</p>
<p>この種類のメソッドは以下の３つあります：</p>
<ul>
<li>TranslateByDist(dist, translate) … 速度指令で、指定距離を前進する</li>
<li>RotateByDeg(Deg, rotate) … 回転指令で、指定角度（度）を回転する</li>
<li>RotateByRad(Rad, rotate) … 回転指令で、指定角度（弧度）を回転する</li>
</ul>
<pre><code class="hljs c#"><span class="hljs-comment">// dist 距離、translate 前進指示値</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">TranslateByDist</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> dist, <span class="hljs-keyword">double</span> translate</span>)</span>;
<span class="hljs-comment">// drad 角度（弧度）、rotate 回転指示値</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">RotateByRad</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> drad, <span class="hljs-keyword">double</span> rotate</span>)</span>;
<span class="hljs-comment">// drad 角度（度）、rotate 回転指示値</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">RotateByDeg</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> ddeg, <span class="hljs-keyword">double</span> rotate</span>)</span>;</code></pre><p>One-Shot メソッドは Movement インスタンスを返すので、Movement クラスの Exec 関数、 あるいは CubeHandle クラスの Move 関数を使ってキューブを移動させてください。</p>
<p>以下は One-Shot メソッドを使って、2 秒間隔で 100 距離前進と 90 度回転の繰り返すことで正方形を描く例です。</p>
<div align="center"><img width="256" src="../res/tutorial_cubehandle/oneshot.gif"></div>

<pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> elapsedTime = <span class="hljs-number">1.5f</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> phase = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
{
    elapsedTime += Time.deltaTime;

    <span class="hljs-keyword">if</span> (<span class="hljs-number">2f</span> &lt; elapsedTime) <span class="hljs-comment">// Every 2 seconds</span>
    {
        cubeManager.handles[<span class="hljs-number">0</span>].Update();
        cubeManager.handles[<span class="hljs-number">1</span>].Update();

        <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">// Phase 0: 100距離を前進</span>
            cubeManager.handles[<span class="hljs-number">0</span>].TranslateByDist(dist:<span class="hljs-number">100</span>, translate:<span class="hljs-number">40</span>).Exec();
            cubeManager.handles[<span class="hljs-number">1</span>].TranslateByDist(dist:<span class="hljs-number">100</span>, translate:<span class="hljs-number">80</span>).Exec();<span class="hljs-comment">//速度を変えてみる</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">1</span>)
        {
            <span class="hljs-comment">// Phase 1: 90度を回転</span>
            cubeManager.handles[<span class="hljs-number">0</span>].RotateByDeg(deg:<span class="hljs-number">90</span>, rotate:<span class="hljs-number">40</span>).Exec();
            cubeManager.handles[<span class="hljs-number">1</span>].RotateByRad(Mathf.PI/<span class="hljs-number">2</span>, <span class="hljs-number">20</span>).Exec();<span class="hljs-comment">//弧度指定も可</span>
            phase = <span class="hljs-number">-1</span>;
        }

        elapsedTime = <span class="hljs-number">0.0f</span>; phase += <span class="hljs-number">1</span>;
    }
}</code></pre><h3 id="指定した座標方向に到達する-closed-loop-メソッド">指定した座標/方向に到達する Closed-Loop メソッド</h3>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-CubeHandle/3.ToTargetScene/」 にあります。</p>
</blockquote>
<p>繰り返し実行し続けることで、マットの指定した座標、指定した方向に到達するのが Closed-Loop メソッドです。</p>
<ul>
<li>Move2Target(...) … 目標座標に移動する</li>
<li>Rotate2Target(...) … 目標座標に回転する</li>
<li>Rotate2Deg(...) … 目標絶対角度（度）に回転する</li>
<li>Rotate2Rad(...) … 目標絶対角度（弧度）に回転する</li>
</ul>
<p>この種類のメソッドは目標に達するまで、毎フレーム呼び出し続ける必要があります。</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Move2Target</span>(<span class="hljs-params">
    <span class="hljs-keyword">double</span> tarX,            // 目標座標ｘ
    <span class="hljs-keyword">double</span> tarY,            // 目標座標ｙ
    <span class="hljs-keyword">double</span> maxSpd = <span class="hljs-number">50</span>,     // 最大速度指示値
    <span class="hljs-keyword">int</span> rotateTime = <span class="hljs-number">250</span>,   // 希望回転時間（ms）
    <span class="hljs-keyword">double</span> tolerance = <span class="hljs-number">8</span>    // 到達判定の閾値
    </span>)</span>;
<span class="hljs-comment">// tarRad 指定角度（弧度）、tolerance 到達判定の閾値(弧度)、rotateTime 希望回転時間（ms）</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Rotate2Rad</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> tarRad, <span class="hljs-keyword">double</span> tolerance = <span class="hljs-number">0.15</span>, <span class="hljs-keyword">int</span> rotateTime = <span class="hljs-number">400</span></span>)</span>;
<span class="hljs-comment">// tarDeg 指定角度（度）、tolerance 到達判定の閾値(度)、rotateTime 希望回転時間（ms）</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Rotate2Deg</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> tarDeg, <span class="hljs-keyword">double</span> tolerance = <span class="hljs-number">5</span>, <span class="hljs-keyword">int</span> rotateTime = <span class="hljs-number">400</span></span>)</span>;
<span class="hljs-comment">// tarX, tarY 指定座標、tolerance 到達判定の閾値(弧度)、rotateTime 希望回転時間（ms）</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Movement <span class="hljs-title">Rotate2Target</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> tarX, <span class="hljs-keyword">double</span> tarY, <span class="hljs-keyword">double</span> tolerance = <span class="hljs-number">0.1</span>, <span class="hljs-keyword">int</span> rotateTime = <span class="hljs-number">400</span></span>)</span>;</code></pre><p>Closed-Loop メソッドは Movement インスタンスを返すので、Movement クラスの Exec 関数、 あるいは CubeHandle クラスの Move 関数を使ってキューブを移動させてください。</p>
<h4 id="例１-指定した座標に移動する">例１: 指定した座標に移動する</h4>
<p>単純に目標座標に移動するなら、すごくシンプルにできます。</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handle <span class="hljs-keyword">in</span> cubeManager.syncHandles)
    {
        handle.Move2Target(<span class="hljs-number">250</span>, <span class="hljs-number">250</span>).Exec();
    }
}</code></pre><h4 id="例-2-指定した座標に移動した後、マットの--90-度方向に向く">例 2: 指定した座標に移動した後、マットの -90 度方向に向く</h4>
<p>Movement クラスの Exec 関数は、実際に実行された Movement インスタンスを返します。<br>
このインスタンスには Move2Target などの関数が目標に達したかの情報も含まれています。</p>
<p>以下の例では、 最初に指定した座標に向かい、目標座標に到達した場合に処理を変え、マットの-90° 方向にキューブを回転させています。</p>
<div align="center"><img width="256" src="../res/tutorial_cubehandle/toTarget.gif"></div>

<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handle <span class="hljs-keyword">in</span> cubeManager.syncHandles)
    {
        <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">0</span>)
        {
            Movement mv = handle.Move2Target(<span class="hljs-number">250</span>, <span class="hljs-number">250</span>).Exec();

            <span class="hljs-comment">// 目標達成したら、次のフェーズに移る。</span>
            <span class="hljs-keyword">if</span> (mv.reached) phase = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">1</span>)
        {
            Movement mv = handle.Rotate2Deg(<span class="hljs-number">-90</span>).Exec();
            <span class="hljs-comment">// or equally use Rotate2Rad(-Mathf.PI/2) or Rotate2Target(handle.x, 0)</span>
        }
    }
}</code></pre><h2 id="follow-targetpole-デモ">Follow TargetPole デモ</h2>
<blockquote>
<p>※ この章のサンプルファイルは、「Assets/toio-sdk/Tutorials/2.Advanced-CubeHandle/ex.FollowTargetPole/」 にあります。</p>
</blockquote>
<p>これまで説明してきた機能を使い、 Stage の TargetPole 機能（シミュレータで使える仮想的な目的地）を利用して、マウスでキューブをコントロールしてみましょう。</p>
<div align="center"><img width="256" src="../res/tutorial_cubehandle/followTargetPole.gif"></div>

<p>まず Stage を取得します。</p>
<pre><code class="hljs c#">Stage stage;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
{
    ...
    stage = GameObject.FindObjectOfType&lt;Stage&gt;();
}</code></pre><p>次に、 TargetPole のマット座標を取得して、 CubeHandle クラスの Move2Target 関数にセットします。</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handle <span class="hljs-keyword">in</span> cubeManager.syncHandles)
    {
        Movement mv = handle.Move2Target(stage.targetPoleCoord).Exec();
    }
}</code></pre><p>これで、 Stage の TargetPole を（マウスでドラッグして）動かすと、それをキューブが追いかけるようになるはずです。</p>



</body></html>
