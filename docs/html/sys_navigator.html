<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"><style type="text/css">.markdown-body {padding: 20px 40px;}</style><style type="text/css">/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
/*# sourceURL=/Users/yaeda/.nodebrew/node/v14.3.0/lib/node_modules/md-to-pdf/node_modules/highlight.js/styles/github.css*/</style></head>
<body class="markdown-body">
<h1 id="目次">目次</h1>
<ul>
<li><a href="sys_navigator.html#1-%E6%A6%82%E8%AA%AC">1. 概説</a><ul>
<li><a href="sys_navigator.html#11-%E3%82%AF%E3%83%A9%E3%82%B9%E3%83%80%E3%82%A4%E3%82%A2%E3%82%B0%E3%83%A9%E3%83%A0">1.1. クラスダイアグラム</a></li>
</ul>
</li>
<li><a href="sys_navigator.html#2-Navigator%E3%82%AF%E3%83%A9%E3%82%B9">2. Navigator クラス</a><ul>
<li><a href="sys_navigator.html#21-%E5%88%B6%E5%BE%A1%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%9B%B3">2.1. 制御ブロック図</a></li>
<li><a href="sys_navigator.html#22-%E3%83%A2%E3%83%BC%E3%83%89">2.2. モード</a></li>
</ul>
</li>
<li><a href="sys_navigator.html#3-CubeNavigator%E3%82%AF%E3%83%A9%E3%82%B9">3. CubeNavigator クラス</a><ul>
<li><a href="sys_navigator.html#31-%E5%88%B6%E5%BE%A1%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%9B%B3">3.1. 制御ブロック図</a></li>
<li><a href="sys_navigator.html#32-%E5%86%85%E9%83%A8%E5%87%A6%E7%90%86%E3%81%AE%E8%A7%A3%E8%AA%AC">3.2. 内部処理の解説</a></li>
<li><a href="sys_navigator.html#33-%E6%8B%A1%E5%BC%B5%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">3.3. 拡張について</a></li>
</ul>
</li>
<li><a href="sys_navigator.html#4-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%AE%E8%A9%B3%E7%B4%B0">4. アルゴリズムの詳細</a><ul>
<li><a href="sys_navigator.html#41-%E3%83%92%E3%83%A5%E3%83%BC%E3%83%9E%E3%83%B3%E3%83%A9%E3%82%A4%E3%82%AF%E8%A1%9D%E7%AA%81%E5%9B%9E%E9%81%BF-HLAvoid">4.1. ヒューマンライク衝突回避 HLAvoid</a></li>
<li><a href="sys_navigator.html#42-%E3%83%9C%E3%82%A4%E3%83%89-Boids">4.2. ボイド Boids</a></li>
</ul>
</li>
</ul>
<h1 id="1-概説">1. 概説</h1>
<div align="center">
<img width="500" src="../res/navigator/overview.png">
</div>

<br>

<p>Navigator とは、複数のロボット（コアキューブ）が存在する時、お互いのロボットの動きを考慮しながら上手く移動するために作られたアルゴリズムです。</p>
<p>このアルゴリズムは主に「ヒューマンライク衝突回避」(HLAvoid)と「ボイド」(Boids)二つのアルゴリズムに基づいています。</p>
<ul>
<li>HLAvoid は自然に回避する手法</li>
<li>Boids は群れとして、同調した動作をする手法</li>
</ul>
<p>ディレクトリ構成は下図のようになります。</p>
<div align="center"><img src="../res/navigator/dir.png"></div>

<pre><code class="hljs plaintext">Navigation  +----------------------+ Navigator 関連ディレクトリ
├── Boids.cs  +--------------------+ ボイドのアルゴリズム実装クラス
├── CubeInterface.cs  +------------+ CubeNavigatorクラスおよびCubeEntityクラス
├── Entities.cs  +-----------------+ Entityクラス
├── HLAvoid.cs  +------------------+ HLAVoid衝突回避のアルゴリズム実装クラス
└── Navigator.cs  +----------------+ Navigatorクラス</code></pre><h2 id="11-クラスダイアグラム">1.1. クラスダイアグラム</h2>
<p>ToioSDK の Navigator モジュール群は、 toio 関連とは独立して実装されている <a href="sys_navigator.html#2-Navigator%E3%82%AF%E3%83%A9%E3%82%B9">Navigator</a> クラス(図の 「Cube-independent Navigator」)と、
Navigator と CubeHandle とをつなげるインターフェイスである <a href="sys_navigator.html#3-CubeNavigator%E3%82%AF%E3%83%A9%E3%82%B9">CubeNavigator</a> クラス および CubeEntity クラス (図の 「Interfavce for Cube」) とで構成されています。</p>
<div align="center"><img width="600" src="../res/navigator/arch.png"></div>

<h1 id="2-navigator-クラス">2. Navigator クラス</h1>
<h2 id="21-制御ブロック図">2.1. 制御ブロック図</h2>
<p>Navigator クラスの制御ブロック図は以下のようになっています。</p>
<div align="center"><img width="700" src="../res/navigator/flow.png"></div>

<ul>
<li>Entity は仮想の 「ロボット」 を表しています。
外部から、Entity に状態情報を与える必要があります。</li>
<li>Boids は "自身の Entity (Entity)"、 "自分以外の Entity（Other Entity リスト）"、 "自分以外の Entity との関係（Relations）" と "目標（Target）" を入力として受け取り、
制御量として "力のベクトル" と "速度係数" を出力します。</li>
<li>HLAvoid は "自身の Entity"、 "自分以外の Entity"、 "Wall リスト" 及び "目標" を入力として受け取り、 "ウェイポイント(経路上の地点情報)" と "速度上限" を出力します。</li>
<li>オレンジ色の出力の流れは、Navigator の<a href="sys_navigator.html#22-%E3%83%A2%E3%83%BC%E3%83%89">モード</a>によって異なります。</li>
</ul>
<h2 id="22-モード">2.2. モード</h2>
<p>Navigator には 3 つのモード （Navigator.Mode） があります。</p>
<ul>
<li>AVOID： 衝突回避のみ</li>
<li>BOIDS： ボイドのみ</li>
<li>BOIDS_AVOID： ボイドと衝突回避の組み合わせ</li>
</ul>
<p>このモードによって、情報の経路は以下のように異なります。</p>
<ul>
<li>AVOID： Boids の出力は無効になり、 HLAvoid のみが目標を入力として受けとり、ウェイポイントを出力する</li>
<li>BOIDS： HLAvoid の出力は無効になり、 Boids のみが目標を入力として受けとり、力ベクトルをウェイポイントとして出力する</li>
<li>BOIDS_AVOID：<ol>
<li>まず Boids が目標を入力として受けとり、力ベクトルを出力する</li>
<li>Boids が出力した力ベクトルを目標に加え、その結果を HLAvoid の入力にする</li>
<li>HLAvoid が出力するウェイポイントを最終的な出力にする</li>
</ol>
</li>
</ul>
<figure align="center">
    <img width="1200" src="../res/navigator/modes.png">
    <figcaption>各モードの制御ブロック図（AVOID、BOIDS、BOIDS_AVOID）</figcaption>
</figure>
<br>

<h1 id="3-cubenavigator-クラス">3. CubeNavigator クラス</h1>
<p>Navigator クラスを継承し、 CubeHandle を使ってキューブが衝突回避/集団制御を行えるようにしたものが CubeNavigator クラスです。</p>
<h2 id="31-制御ブロック図">3.1. 制御ブロック図</h2>
<h3 id="311-cubehandle-の制御ブロック図">3.1.1. CubeHandle の制御ブロック図</h3>
<p>まず最初に CubeHandle の制御ブロック図を以下に示します。</p>
<figure align="center">
  <img src="../res/cubehandle/arch.png">
  <figcaption>CubeHandle 制御ブロック図</figcaption>
</figure>
<br>

<p>CubeHandle では以下のようなことを行います。 (詳細は usage_cubehandle.html を参照してください)</p>
<ul>
<li><code>CubeHandle.Update</code> メソッドが Cube の情報を取得し、状態予測を行う</li>
<li><code>CubeHandle.Move2Target</code> メソッドが、 目標 を入力として受けとり、移動命令を計算する</li>
<li>出力された移動命令を <code>CubeHandle.Move</code> メソッドもしくは <code>Movemnet.Exec</code> メソッドで実行する</li>
</ul>
<h3 id="312-cubenavigator-の制御ブロック図">3.1.2. CubeNavigator の制御ブロック図</h3>
<p>次に CubeNavigator の制御ブロック図を以下に示します。</p>
<div align="center"><img width="900" src="../res/navigator/cubenavigator.png"></div>
<br>

<p>CubeNavigator では、 Navigator と CubeHandle を組み合わせて</p>
<ol>
<li><code>CubeHandle.Update</code> メソッドを呼び出し、予測結果と元情報を CubeEntity にセットする (<code>CubeNavigator.Update</code> メソッド)</li>
<li>Navigator のナビゲーションアルゴリズムを実行する</li>
<li>ナビゲーションの結果（ウェイポイント座標、速度）を <code>CubeHandle.Move2Target</code> メソッドに与えて移動命令を計算する (<code>CubeNavigator.Navi2Target, CubeNavigator.NaviAwayTarget</code> メソッド)</li>
<li>出力された移動命令を <code>CubeHandle.Move</code> メソッドもしくは <code>Movemnet.Exec</code> メソッドで実行する</li>
</ol>
<p>という手順でキューブを制御しています。</p>
<h2 id="32-内部処理の解説">3.2. 内部処理の解説</h2>
<h3 id="321-update">3.2.1. Update</h3>
<p><code>CubeHandle.Update</code> メソッドを呼び出し、予測結果と元情報を CubeEntity にセットします。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// CubeNavigator.Update</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CubeNavigator</span> : <span class="hljs-title">Navigator</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> usePred</span>)</span>
    {
        <span class="hljs-keyword">if</span> (Time.time - updateLastTime &lt; <span class="hljs-number">0.015</span>) <span class="hljs-keyword">return</span>;
        updateLastTime = Time.time;
        <span class="hljs-keyword">this</span>.handle.Update();
        (ego <span class="hljs-keyword">as</span> CubeEntity).Update(usePred);
    }
    ...
}

<span class="hljs-comment">// CubeEntity.Update</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CubeEntity</span> : <span class="hljs-title">Entity</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> usePred=<span class="hljs-literal">false</span></span>)</span>{
        <span class="hljs-keyword">if</span> (usePred)
        {
            x = handle.xPred;
            y = handle.yPred;
            pos = <span class="hljs-keyword">new</span> Vector(x, y);
            rad = handle.radPred;
            spdL = handle.spdPredL;
            spdR = handle.spdPredR;
            spd = handle.spdPred;
            w = handle.wPred;
            v = handle.vPred;
        }
        <span class="hljs-keyword">else</span>{
            x = handle.x;
            y = handle.y;
            pos = handle.pos;
            rad = handle.rad;
            spdL = handle.spdL;
            spdR = handle.spdR;
            spd = handle.spd;
            w = handle.w;
            v = handle.v;
        }
    }
    ...
}</code></pre><h3 id="322-navi2target-naviawaytarget">3.2.2. Navi2Target, NaviAwayTarget</h3>
<p>入力された目標値から Navigator に実装されているアルゴリズムでウェイポイントなどを計算し、その結果を <code>CubeHandle.Move2Target</code> に渡します。</p>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Movement <span class="hljs-title">Navi2Target</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y, <span class="hljs-keyword">int</span> maxSpd=<span class="hljs-number">70</span>, <span class="hljs-keyword">int</span> rotateTime=<span class="hljs-number">250</span>, <span class="hljs-keyword">double</span> tolerance=<span class="hljs-number">20</span></span>)</span>
{
    <span class="hljs-comment">// Navigator のウェイポイント計算</span>
    <span class="hljs-keyword">this</span>.result = <span class="hljs-keyword">base</span>.GetWaypointTo(x, y);
    <span class="hljs-comment">// 速度を設定</span>
    <span class="hljs-keyword">var</span> spd = Min(<span class="hljs-keyword">this</span>.result.speedLimit, maxSpd*<span class="hljs-keyword">this</span>.result.speedRatio);

    <span class="hljs-comment">// CubeHandle.Move2Target で移動命令計算</span>
    <span class="hljs-keyword">var</span> mv = handle.Move2Target(<span class="hljs-keyword">this</span>.result.waypoint,
        maxSpd:spd, rotateTime:rotateTime, tolerance:<span class="hljs-number">8</span>
    );

    <span class="hljs-comment">// 到達判定</span>
    <span class="hljs-keyword">if</span> (ego.pos.distTo(<span class="hljs-keyword">new</span> Vector(x,y)) &lt;= tolerance &amp;&amp; mv.reached)
        <span class="hljs-keyword">return</span> mv;
    <span class="hljs-keyword">else</span>{
        mv.reached = <span class="hljs-literal">false</span>; <span class="hljs-keyword">return</span> mv;
    }
}</code></pre><h2 id="33-拡張について">3.3. 拡張について</h2>
<ul>
<li>ナビゲーションの結果（ウェイポイント、速度上限、速度係数）から、モーター指示値までの計算を変更したい</li>
<li>到達判定方法を変更したい</li>
</ul>
<p>などを実現したい場合は、 CubeNavigator を継承し、Navi2Target メソッドと NaviAwayTarget メソッドをオーバーライドしてください。</p>
<h1 id="4-アルゴリズムの詳細">4. アルゴリズムの詳細</h1>
<p>以下で紹介するアルゴリズムは Morikatron Engineer Blog でも解説しています。<br>
そちらも参照してください。</p>
<p><a href="https://tech.morikatron.ai/entry/2020/03/04/100000">ウロチョロスに用いた集団行動の制御手法(Morikatron Engineer Blog)</a></p>
<h2 id="41-ヒューマンライク衝突回避-hlavoid">4.1. ヒューマンライク衝突回避 HLAvoid</h2>
<p>ヒューマンライク衝突回避は、要約すると</p>
<ul>
<li>各方向に向かって最大速度で前進して、</li>
<li>他のロボットが方向と速度を維持すると どの程度の距離で衝突するかを計算し、</li>
<li>衝突する前の領域において目標と一番近いポイントを目指す
という流れでロボットが他のロボットと衝突をしないように行動するアルゴリズムです。</li>
</ul>
<blockquote>
<p>各方向の距離を計算することを「スキャン」と呼びます。</p>
</blockquote>
<div align="center">
<img width="500" src="../res/navigator/HLAvoid.png">
<figcaption>※ 図は <a href="https://ieeexplore.ieee.org/abstract/document/6630610">元論文</a>から引用</figcaption>
</div>

<p>ToioSDK の HLAvoid クラスは機能としてのメソッドを 2 つ持っています。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// 目標にナビゲーションする（ウェイポイント、衝突状態、速度上限）を計算</span>
<span class="hljs-keyword">public</span> (Vector, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">double</span>) RunTowards(List&lt;Navigator&gt; others, Entity target, List&lt;Wall&gt; walls);
<span class="hljs-comment">// 目標から逃げる（ウェイポイント、衝突状態、速度上限）を計算</span>
<span class="hljs-keyword">public</span> (Vector, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">double</span>) RunAway(List&lt;Navigator&gt; others, Entity target, List&lt;Wall&gt; walls);</code></pre><p>内部関数の呼び出し関係は以下のようになっています。</p>
<p>RunTowards / RunAway</p>
<ul>
<li>SampleRads ------------------------- スキャンの方向をサンプリング</li>
<li>Scan<ul>
<li>ScanTar ------------------------- 目標のある方向をスキャン</li>
<li>ScanOthers<ul>
<li>_ScanEntity -------------- 視野内の Entity を各々スキャン</li>
<li>CombineScanRes ------ 各スキャン結果を統合</li>
</ul>
</li>
<li>ScanWalls<ul>
<li>_ScanWall ---------------- 視野内の Wall を各々スキャン</li>
<li>CombineScanRes ------ 各スキャン結果を統合</li>
</ul>
</li>
<li>CombineScanRes ------------ 各スキャン結果を統合</li>
</ul>
</li>
<li>スキャンの結果でウェイポイントと速度上限を計算</li>
</ul>
<h3 id="411-スキャンの結果を表す-scanresult-構造体">4.1.1. スキャンの結果を表す ScanResult 構造体</h3>
<pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> ScanResult
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isCollision;    <span class="hljs-comment">// 衝突状態</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] rads;       <span class="hljs-comment">// スキャンの方向</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] dists;      <span class="hljs-comment">// 距離</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] safety;     <span class="hljs-comment">// 安全性</span>
    <span class="hljs-keyword">public</span> Vector[] points;     <span class="hljs-comment">// 方向と距離で決まるポイントの相対座標</span>

    <span class="hljs-comment">// 初期化済みの ScanResult を作成用</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScanResult <span class="hljs-title">init</span>(<span class="hljs-params"><span class="hljs-keyword">double</span>[] rads, <span class="hljs-keyword">double</span> maxRange</span>)</span>;
    <span class="hljs-comment">// デバッグ用</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params">Action&lt;<span class="hljs-keyword">string</span>&gt; func</span>)</span>;
    <span class="hljs-comment">// rads と dists で points を計算</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calcPoints</span>(<span class="hljs-params"></span>)</span>;
}</code></pre><h3 id="412-スキャンの結果を統合する-combinescanres-メソッド">4.1.2. スキャンの結果を統合する CombineScanRes メソッド</h3>
<pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> ScanResult <span class="hljs-title">CombineScanRes</span>(<span class="hljs-params">List&lt;ScanResult&gt; results, <span class="hljs-keyword">bool</span> isCol, <span class="hljs-keyword">double</span>[] rads</span>)</span>;</code></pre><p>複数の ScanResult を以下のように統合します。</p>
<ul>
<li>各方向の距離の最小値を取る</li>
<li>各方向の安全性の最小値を取る</li>
</ul>
<h3 id="413-アルゴリズム：スキャンの計算方法とウェイポイントの選び方">4.1.3. アルゴリズム：スキャンの計算方法とウェイポイントの選び方</h3>
<p>元論文　<a href="https://ieeexplore.ieee.org/abstract/document/6630610">Guzzi, Jérôme, et al. "Human-friendly robot navigation in dynamic environments." 2013 IEEE International Conference on Robotics and Automation. IEEE, 2013.</a> <br>
及び <a href="https://tech.morikatron.ai/entry/2020/03/04/100000">改良版手法の解説ブログ</a>（Morikatron Engineer Blog）を参照してください。</p>
<details>
<summary>_ScanEntity 実装コード</summary>

<pre><code class="hljs c#"><span class="hljs-keyword">private</span> ScanResult _ScanEntity(Navigator other, <span class="hljs-keyword">double</span>[] rads){
    ScanResult res = ScanResult.init(rads, maxRange);
    <span class="hljs-keyword">var</span> o = other.entity;
    <span class="hljs-keyword">var</span> marginSum = margin + other.avoid.margin;

    <span class="hljs-comment">// Scan for safe distance to other</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;rads.Length; ++i)
    {
        <span class="hljs-keyword">var</span> rad = rads[i];
        <span class="hljs-keyword">var</span> v = Vector.fromRadMag(rad, Max(ego.spd, <span class="hljs-number">10</span>));
        <span class="hljs-keyword">var</span> vUnit = Vector.fromRadMag(rad, <span class="hljs-number">1</span>);

        <span class="hljs-keyword">var</span> dV = v - o.v;
        <span class="hljs-keyword">var</span> dPos = ego.pos - o.pos;

        <span class="hljs-keyword">var</span> a = dV * dV;
        <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span> * dV * dPos;
        <span class="hljs-keyword">var</span> c = dPos * dPos - marginSum * marginSum;
        <span class="hljs-keyword">var</span> delta = b * b - <span class="hljs-number">4</span> * a * c;

        <span class="hljs-keyword">double</span> dist;
        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span> || Abs(a) &lt; <span class="hljs-number">1</span>)    <span class="hljs-comment">// No collision</span>
        {
            dist = maxRange;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">var</span> t1 = (-b - Sqrt(delta)) / <span class="hljs-number">2</span> / a;
            <span class="hljs-keyword">var</span> t2 = (-b + Sqrt(delta)) / <span class="hljs-number">2</span> / a;

            <span class="hljs-keyword">if</span> (t2 &lt;= <span class="hljs-number">0</span>)            <span class="hljs-comment">// No collision in future</span>
                dist = maxRange;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t1 &gt; <span class="hljs-number">0</span>)        <span class="hljs-comment">// Collsion in future</span>
                dist = t1 * v.mag;
            <span class="hljs-keyword">else</span> {                   <span class="hljs-comment">// Collsion Now</span>
                dist = Max(<span class="hljs-number">0.1</span>, vUnit * dPos.unit * <span class="hljs-number">100</span>);
                res.isCollision = <span class="hljs-literal">true</span>;
            }
        }

        res.dists[i] = dist;
    }

    <span class="hljs-comment">// When Collison, Find available rads.</span>
    <span class="hljs-keyword">if</span> (res.isCollision){
        <span class="hljs-keyword">var</span> dPos = o.pos - ego.pos;
        <span class="hljs-keyword">var</span> colSeverity = Max(<span class="hljs-number">0</span>, margin+o.margin - dPos.mag)/margin;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;rads.Length; ++i){
            res.safety[i] = Cos(AbsRad(rads[i] - (-dPos).rad)) * (<span class="hljs-number">1</span> + colSeverity) ;
        }
    }

    <span class="hljs-keyword">return</span> res;
}</code></pre></details>

<br>

<details>
<summary>RunTowards 実装コード</summary>

<pre><code class="hljs c#"><span class="hljs-keyword">public</span> (Vector, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">double</span>) RunTowards(List&lt;Navigator&gt; others, Entity target, List&lt;Wall&gt; walls){

    <span class="hljs-keyword">var</span> rads = SampleRads(target);

    <span class="hljs-keyword">var</span> (res, resCol) = Scan(others, target, walls, rads);
    res.calcPoints(); resCol.calcPoints();

    waypointIndex = <span class="hljs-number">0</span>;
    Vector waypoint = Vector.zero;

    <span class="hljs-comment">// find waypoint by res, which is the scan result of objects NOT in collision</span>
    {
        <span class="hljs-keyword">double</span> minDist = <span class="hljs-keyword">double</span>.MaxValue;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;rads.Length; ++i)
        {
            <span class="hljs-comment">// nearest point at certain rad</span>
            <span class="hljs-keyword">var</span> nearestMag = Max( Cos((target.pos-ego.pos).rad - rads[i]) * ego.pos.distTo(target.pos) , <span class="hljs-number">1</span> );
            <span class="hljs-keyword">var</span> mv = res.points[i].clip(nearestMag);
            res.points[i] = mv;

            <span class="hljs-comment">// distance of waypoint to target</span>
            <span class="hljs-keyword">var</span> dist = (ego.pos + mv).distTo(target.pos);

            <span class="hljs-comment">// penalty of turning</span>
            <span class="hljs-comment">// NOTE may cause not turning when target right behind ego</span>
            dist += Max(AbsRad(ego.rad - rads[i]), <span class="hljs-number">0.5</span>) * <span class="hljs-number">0.1</span>;
            dist += Max((AbsRad(ego.rad - rads[i]) - PI/<span class="hljs-number">2</span>), <span class="hljs-number">0</span>) * <span class="hljs-number">2</span>;

            <span class="hljs-comment">// Search Nearest waypoint away from target, with SAFE direction</span>
            <span class="hljs-keyword">if</span> (dist &lt; minDist &amp;&amp; resCol.safety[i] &gt; p_waypoint_safety_threshold)
            {
                minDist = dist; waypointIndex = i;
            }
        }

        <span class="hljs-keyword">if</span> (minDist &lt; <span class="hljs-keyword">double</span>.MaxValue){
            waypoint = res.points[waypointIndex];
        }
    }

    <span class="hljs-comment">// ====  Speed Limit  ====</span>
    <span class="hljs-keyword">double</span> speedLimit = <span class="hljs-keyword">double</span>.MaxValue;
    <span class="hljs-keyword">var</span> waypointRad = rads[waypointIndex];
    <span class="hljs-comment">// slow down when colliders are close around.</span>
    {
        <span class="hljs-keyword">double</span> minRadius = <span class="hljs-number">1e10</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;rads.Length; ++i){
            <span class="hljs-keyword">var</span> rad = rads[i];
            <span class="hljs-keyword">if</span> (res.dists[i] &lt; <span class="hljs-number">50</span> &amp;&amp;
                (Rad(rad-ego.rad)&gt;<span class="hljs-number">0.1</span> &amp;&amp; Rad(waypointRad-rad)&gt;<span class="hljs-number">0.1</span> ||
                    Rad(ego.rad-rad)&gt;<span class="hljs-number">0.1</span> &amp;&amp; Rad(rad-waypointRad)&gt;<span class="hljs-number">0.1</span> ))
            {
                <span class="hljs-comment">// minimal maximal turning radius</span>
                minRadius = Min(minRadius, (res.dists[i]+<span class="hljs-number">20</span>) / (<span class="hljs-number">2</span>* Sin(Abs(rad-ego.rad))) );
            }
        }
        speedLimit = Max(<span class="hljs-number">8</span>, minRadius * Max(<span class="hljs-number">1</span>, Abs(ego.w)));
    }
    <span class="hljs-comment">// stop when ego.rad is pointing insides colliders.</span>
    <span class="hljs-keyword">if</span> (resCol.isCollision)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;rads.Length; ++i){
            <span class="hljs-keyword">var</span> rad = rads[i];
            <span class="hljs-keyword">if</span> (AbsRad(rad - ego.rad) &lt; PI*<span class="hljs-number">2</span>/nsample
                &amp;&amp; resCol.safety[i] &lt;= <span class="hljs-number">0</span>
            ){
                speedLimit = <span class="hljs-number">100</span> * Max(<span class="hljs-number">0</span>, resCol.safety[i] * <span class="hljs-number">2</span> +<span class="hljs-number">1</span>);
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    <span class="hljs-comment">// make result</span>
    res.rads = rads;
    scanResult = res;
    <span class="hljs-keyword">return</span> (waypoint, resCol.isCollision, speedLimit);
}</code></pre></details>

<br>

<h2 id="42-ボイド-boids">4.2. ボイド Boids</h2>
<p>ボイドは鳥の集団行動を擬似するアルゴリズムで、下図のように、三つの簡単なルールで実現されています。</p>
<ul>
<li>Separation: 他個体から離れる</li>
<li>Alignment: 周囲の個体の平均方向に向かう</li>
<li>Cohesion: 周囲の個体の平均位置に移動する</li>
</ul>
<div align="center">
<img width="300" src="../res/navigator/boids.png">
<figcaption>※ <a href="http://www.red3d.com/cwr/boids/">Reynolds, Craig. Boids(Webpage)</a>から引用</figcaption>
</div>

<p>ToioSDK の Boids クラスは機能としてのメソッドを 2 つ持っています。</p>
<pre><code class="hljs c#"><span class="hljs-comment">// 目標への「引力」を含めて、ボイドの力ベクトルを計算</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Vector <span class="hljs-title">Run</span>(<span class="hljs-params">List&lt;Navigator&gt; others, Vector tarPos</span>)</span>;
<span class="hljs-comment">// 目標への「引力」なしで、ボイドの力ベクトルを計算</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Vector <span class="hljs-title">Run</span>(<span class="hljs-params">List&lt;Navigator&gt; others</span>)</span>;</code></pre><h3 id="呼び出し関係">呼び出し関係</h3>
<h4 id="run">Run</h4>
<ul>
<li>Attract -------- 目標の「引力」</li>
<li>Separate ----- 離れる力</li>
<li>Cohesion ---- 平均位置に移動する力</li>
<li>Alignment ---- 平均方向に向かう力</li>
<li>重み付け、制限、合力の計算</li>
</ul>
<p>アルゴリズムのより詳しい説明は <a href="http://www.red3d.com/cwr/boids/">Reynolds, Craig. Boids(Webpage)</a> を参照してください。</p>



</body></html>
